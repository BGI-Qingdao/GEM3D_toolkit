import sys
import pandas as pd
import numpy as np
import anndata
from skimage import io as skio
import getopt
import json
import scipy.ndimage as nd

#Print Usage
def apply_alignment_usage():
    print("""
Usage :
    GEM_toolkit.py apply_alignment -i <input.json or input.csv>
                       -o <output prefix>
                       -W [the width of aligned image, default equal to input image]
                       -H [the height of aligned image, default equal to input image]
                       -m [True/False, merge all h5ad to one if True, default False]
                       -S [True/False, add Sn to cell name if -m=True, default False ]

Example : 
    GEM_toolkit.py apply_alignment -i input.json \\
                                   -o prefix

#-------------------------------------------------------------------------------------------
# Example of input.json  :
# [
#      ['S1',"gemfile_1","h5adfile_1","ssdnafile_1","maskfile_1","[[1,0,10], [0,1,0],[0.0, 0.0, 1.0]]","z_value","[[1,0,0], [0,1,0],[0.0, 0.0, 1]]","outlinefile_1",10,0],
#       ....
#      ['Sn',"gemfile_N","h5adfile_N","ssdnafile_N","maskfile_N","[[1,0,10], [0,1,0],[0.0, 0.0, 1.0]]","z_value","[[1,0,0], [0,1,0],[0.0, 0.0, 1]]","outlinefile_N",0,10]
# ]
#
# Detail of items in data:
#     1. Sn: name of this data.
#     2. gemfile_N: the GEM/GEMC file of this data, use "" if unavaliable.
#     3. h5adfile_N: the h5ad file of this data, use "" if unavailable.
#     4. ssdnafile_N: the ssDNA file of this data, use "" if unavailable.
#     5. maskfile_N: the cell mask file (generated by CellProfiler) of this data, use "" if unavaliable.
#     6. the 3D forward alignment affine matrix, required. 
#     7. the z value for this data, required.
#     8. the 2D backward registration affine matrix, optional, if you align 3D by raw ssDNA, please provide this.
#     9. outlinefile_N, the outline file (genereated based on maskfile_N), use "" if unavaliable.
#    10. x shift, the x coordinate of GEM/h5ad correspond to the the x=0 coordiante of alignment image (and cell mask file).
#    11. y shift, the y coordinate of GEM/h5ad correspond to the the y=0 coordiante of alignment image (and cell mask file).
#
#-------------------------------------------------------------------------------------------

>>># In above json file, you must provide full 11 info for each data #<<<
>>># To make life easier,you may use the more flexible input.csv #<<<
#-------------------------------------------------------------------------------------------
# Example of a tiny input.csv:
#   h5ad,3D_forward,Z_values
#   xx1.h5ad,"[[1,0,10],[0,1,0],[0.0, 0.0, 1.0]]",10
#   ...
#   xxN.h5ad,"[[1,0,10],[0,1,0],[0.0, 0.0, 1.0]]",80
#
# As you see, now you could only need provide available data with any order of your wish.
#
# Correspondence between column-name and JSON data item.
#   ***************************************************************
#   *         flag (default '') -- 1. Sn                          *
#   *          gem (default '') -- 2. gemfile_N                   *
#   *         h5ad (default '') -- 3. h5adfile_N                  *
#   *        ssdna (default '') -- 4. ssdnafile_N                 *
#   *         mask (default '') -- 5. maskfile_N                  *
#   *   3D_forward (required! ) -- 6. the 3D alignment matrix     *
#   *     Z_values (required! ) -- 7. the z value                 *
#   *  2D_backward (default '') -- 8. the 2D registration matrix  *
#   *      outline (default '') -- 9. outlinefile                 *
#   *      x_shift (default 0 ) -- 10. x shift                    *
#   *      y_shift (default 0 ) -- 11. y shift                    *
#   ***************************************************************
#-------------------------------------------------------------------------------------------

Enjoy :)

    """,flush=True)

def checkTrue(s):
    return s.lower() in ['true', '1', 't', 'y', 'yes']

def apply_alignment_main(argv:[]):
    ##############################################
    # parse parameters
    ##############################################
    inputfile=''
    prefix=''
    a="F"
    hflag=False
    W=''
    H=''
    Sflag=False
    try:
        opts ,args =getopt.getopt(argv,"hi:o:m:t:W:H:S:",["help=",
                                                     "input=",
                                                     "output=",])
    except getopt.GetoptError:
        apply_alignment_usage()
        sys.exit(2)
    for opt,arg in opts:
        if opt in ("-h","--help"):
            apply_alignment_usage()
            sys.exit(0)
        elif opt in ("-i","--input"):
            inputfile = arg
        elif opt in ("-o","--output"):
            prefix = arg 
        elif opt in ('-S'):
            Sflag = checkTrue(arg)
        elif opt in ('-m'):
            hflag = checkTrue(arg)
        elif opt in ('-W'):
            W = int(arg)
        elif opt in ('-H'):
            H = int(arg)

    if inputfile == '' or prefix == '':
        apply_alignment_usage()
        sys.exit(0)
    ##############################################
    # loading configs
    ##############################################
    if '.json' in inputfile:
        collections = json.load(open(inputfile,'r'))
    if '.csv' in inputfile:
        _flag=''       #1. Sn
        gem_path=''    #2. gemfile_N
        h5ad_path=''   #3. h5adfile_N
        ssdna_path=''  #4. ssdnafile_N
        mask_path=''   #5. maskfile_N
        _3D=''         #6. the 3D alignment matrix
        _Z_values=''   #7. the z value
        _2D=''         #8. the 2D registration matrix
        outline=''     #9. outlinefile
        x=0            #10. x shift
        y=0            #11. y shift
        data=pd.read_csv(inputfile)
        _columns=data.columns
        collections =[]
        for i in range(len(data)):
            if 'gem' in _columns:
                gem_path=data['gem'][i]
            if 'h5ad' in _columns:
                h5ad_path=data['h5ad'][i]
            if 'ssdna' in _columns:
                ssdna_path=data['ssdna'][i]
            if 'mask' in _columns:
                mask_path=data['mask'][i]
            if '2D_backward' in _columns:
                _2D=data['2D_backward'][i]
            if '3D_forward' in _columns:
                _3D=data['3D_forward'][i]
            if 'Z_values' in _columns:
                _Z_values=data['Z_values'][i]
            if 'flag' in _columns:
                _flag=data['flag'][i]
            if 'outline' in _columns:
                outline =data['outline'][i]
            if 'x_shift' in _columns:
                x=data['x_shift'][i]
            if 'y_shift' in _columns:
                y=data['y_shift'][i]
            #                    0     1        2         3           4        5   6         7   8      9 10
            collections.append([_flag,gem_path,h5ad_path,ssdna_path,mask_path,_3D,_Z_values,_2D,outline,x,y])

    ##############################################
    # handle affine matrix now
    ##############################################
    N=len(collections)
    h5admerge = []
    for i in range(N):
        collection = collections[i]
        if collection[5] == '' or collection[6] == '' :
            print('Error: 3D affine matrix or z value not exist! exit ...',flush=True)
            sys.exit(1)
        try:
            if collection[7] != '' :
                affine_2D_b=np.matrix(np.array(json.loads(collection[7])))
                affine_3D_f=np.matrix(np.array(json.loads(collection[5])))
                affine=np.matmul(affine_3D_f,affine_2D_b)
            else:
                affine=np.matrix(np.array(json.loads(collection[5])))
        except:
            print("Error: matrix err !!!")
            sys.exit(1)
        if collection[1]!='': #gem
            affine_gem(collection[1],prefix,affine,collection[0],collection[6],int(collection[9]),int(collection[10]))
        if collection[2]!='': #h4ad
            h5ad=affine_h5ad(collection[2],prefix,affine,collection[0],collection[6],int(collection[9]),int(collection[10]),Sflag,hflag)
            if hflag==False:
                h5ad.write(f'{prefix}_{collection[0]}.h5ad',compression='gzip')
            else:
                h5admerge.append(h5ad)
                if int(i+1)==int(N):
                    h5adall = anndata.concat(h5admerge,axis=0,join='outer')
                    h5adall.write(f'{prefix}_merged.h5ad',compression='gzip')
        if collection[3]!='': #ssDNA
            affine_ssdna(collection[3],prefix,affine,collection[0],W,H)
        if collection[4]!='': #mask
            affine_txt(collection[4],prefix,affine,collection[0],W,H,'mask')
        if collection[8]!='': #outline
            affine_txt(collection[8],prefix,affine,collection[0],W,H,'outline')

def affine_gem(inputgem,prefix,affine,Sn,zvalue,xmin,ymin):
    df = pd.read_csv(inputgem, sep='\t', comment='#')
    gemxy=df[["x",'y']].copy()
    gemxy['x'] = gemxy['x'] - xmin
    gemxy['y'] = gemxy['x'] - ymin
    gemxy=np.insert(gemxy.to_numpy(),2,values=np.ones((len(gemxy),)),axis=1)
    affine_result=np.dot(affine,gemxy.T)[0:2,:]
    df["new_x"]=np.array(affine_result[0:1,:].T)
    df["new_y"]=np.array(affine_result[1:2,:].T)
    df["z"]= int(zvalue)
    df.to_csv(f"{prefix}_{Sn}.gem",index=None,sep='\t')

def affine_h5ad(inputh5ad,prefix,affine,Sn,zvalue,xmin,ymin,Sflag,hflag):
    h5ad=anndata.read(inputh5ad)
    h5adxy=h5ad.obs[["x",'y']].copy()
    h5adxy['x'] = h5adxy['x'] - xmin
    h5adxy['y'] = h5adxy['y'] - ymin
    h5adxy=np.insert(h5adxy.to_numpy(),2,values=np.ones((len(h5adxy),)),axis=1)
    affine_result=np.dot(affine,h5adxy.T)[0:2,:]
    h5ad.obs['new_x']=np.array(affine_result[0,:].T)
    h5ad.obs['new_y']=np.array(affine_result[1,:].T)
    h5ad.obs['z']=zvalue
    if Sflag and hflag:
        h5ad.obs['tmp'] = h5ad.obs.index
        h5ad.obs.index= h5ad.obs.apply(lambda row : str(Sn)+'_'+str(row['tmp']),axis=1)
        h5ad.obs.drop(columns=['tmp'],inplace=True)
    return h5ad

def affine_ssdna(inputssdna,prefix,affine,Sn,W,H):
    dapi_data = skio.imread(inputssdna)
    if W=='' or H=='':
        if dapi_data.shape == 3:
            H,W,_=dapi_data.shape
        else:
            H,W= dapi_data.shape
    if len(dapi_data.shape) == 3 : # RGB to 8 bit gray 
        new_data = np.zeros((dapi_data.shape[0],dapi_data.shape[1]),dtype=int)
        new_data = new_data + dapi_data[
            :,:,0]
        new_data = new_data + dapi_data[:,:,1]
        new_data = new_data + dapi_data[:,:,2]
        new_data = (new_data+2) / 3
        dapi_data = new_data
    dapi_data = dapi_data.astype('uint8')
    ind = dapi_data
    outd = nd.affine_transform(ind.T,affine.I,output_shape=(W,H),order=0)
    outd = outd.T
    outd = outd.astype('uint8')
    skio.imsave(f'{prefix}_{Sn}.png',outd)

def affine_txt(inputmask,prefix,affine,Sn,W,H,k):
    ind = np.loadtxt(inputmask,delimiter=' ',dtype=int)
    if W=='' or H=='':
        H,W= ind.shape
    outd = nd.affine_transform(ind.T,affine.I,output_shape=(W,H),order=0)
    outd = outd.T
    np.savetxt(f'{prefix}_{Sn}_{k}.txt',outd,fmt="%d")

if __name__ == '__main__':
    import sys
    apply_alignment_main(sys.argv[1:])
